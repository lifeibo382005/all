// Copyright 2012 Volker Dobler. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

package main

//
// recreate the tables with
//   go run maketable.go > table.go && go fmt
//

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"os"
	"strings"
	"time"
)

const tableUrl = "http://mxr.mozilla.org/mozilla-central/source/netwerk/dns/effective_tld_names.dat?raw=1"

type ruleKind uint8

const (
	none ruleKind = iota // not a rule, just internal node
	normalRule
	exceptionRule
	wildcardRule
)

type node struct {
	label string
	kind  ruleKind
	sub   []node
}

func findLabel(label string, nodes []node) *node {
	// do *not* replace with binary search
	for i := range nodes {
		if nodes[i].label == label {
			return &nodes[i]
		}
	}
	return nil
}

func insert(nl []node, parts []string) []node {
	if len(parts) == 1 {
		label := parts[0]
		kind := normalRule
		switch label[0] {
		case '!':
			kind = exceptionRule
			label = label[1:]
		case '*':
			kind = wildcardRule
			label = label[1:]
		}
		if w := findLabel(label, nl); w != nil {
			if w.kind != none {
				log.Fatalf("Duplicate rule for " + label)
			}
			w.kind = kind // just update kind
			return nl
		}
		return append(nl, node{label, kind, nil})
	}
	last := len(parts)-1
	label := parts[last]
	w := findLabel(label, nl)
	if w == nil {
		nl = append(nl, node{label, none, nil})
		w = & nl[len(nl)-1]
	}
	w.sub = insert(w.sub, parts[:last])
	return nl
}

type nodeList []node

func (t nodeList) Len() int { return len(t) }
func (t nodeList) Less(i, j int) bool {
	return t[i].label < t[j].label
}
func (t nodeList) Swap(i, j int) { t[i], t[j] = t[j], t[i] }

func main() {
	var input io.Reader

	if file, err := os.Open("effective_tld_names.dat"); err == nil {
		defer file.Close()
		input = file
	} else {
		resp, err := http.Get(tableUrl)
		if err != nil {
			log.Fatal(err)
		}
		defer resp.Body.Close()
		input = resp.Body
	}
	all, err := ioutil.ReadAll(input)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("// Copyright 2012 Volker Dobler. All rights reserved.")
	fmt.Println("// Use of this source code is governed by a BSD-style")
	fmt.Println("// license that can be found in the LICENSE file.")
	fmt.Println("")
	fmt.Println("package cookiejar")
	fmt.Println("")
	fmt.Println("// This file was generated by performing")
	fmt.Println("//     go run maketable.go")
	fmt.Println("// on ", time.Now().Format(time.RFC1123Z))
	fmt.Println("// Do not modify.")
	fmt.Println("")
	fmt.Println("// A 'public suffix' is one under which Internet users can directly register")
	fmt.Println("// names.  This list is maintained on http://publicsuffix.org/")
	fmt.Println("// See there for a description of the format and further details.")
	fmt.Println("")

	var root []node = make([]node, 0, 200)

	// read in list: remove comments and empty lines, and fill tlds and rules
	lines := strings.Split(string(all), "\n")
	for _, line := range lines {
		// remove noise
		line = strings.TrimSpace(line)
		if len(line) == 0 || strings.HasPrefix(line, "//") {
			continue
		}

		// saveguard for too fancy wildcards
		if strings.Contains(line,"*") {
			if strings.Contains(line[1:], "*") || len(line)<2 || line[1]!='.' {
				log.Fatalf("Cannot handle complex wildcard rule %q", line)
			}
			// transform "*.kobe.jp" to "*kobe.jp"
			line = "*" + line[2:]
		}

		parts := strings.Split(line, ".")
		root = insert(root, parts)
	}

	// write out data structure
	fmt.Printf("var PublicSuffixes = Node{\"\", 0, []Node{\n")
	printNodelist(root, 1)
	fmt.Printf("}}\n")
	fmt.Println()
	fmt.Println("// the needed fibonacci numbers")
	fmt.Printf("var fibonacci = []int{0, 1")
	a, b := 0, 1
	for b<longest {
		n := a + b
		fmt.Printf(", %d", n)
		a, b = b, n
	}
	fmt.Printf("}\n")
	fmt.Println()
	//fmt.Println("// the needed fibonacci numbers")
	// fmt.Printf("var fibonacci = []int{0, 1")

}

var longest int

func printNodelist(list []node, indent int) {
	sort.Sort(nodeList(list))
	if len(list) > longest {
		longest = len(list)
	}
	prefix := strings.Repeat("\t", indent)
	for _, n := range list {
		fmt.Printf("%s{%q, %d, ", prefix, n.label, n.kind)
		if len(n.sub) == 0 {
			fmt.Printf("nil},\n")
		} else {
			fmt.Printf("[]Node{\n")
			printNodelist(n.sub, indent+1)
			fmt.Printf("%s},\n%s},\n", prefix, prefix)
		}
	}
}